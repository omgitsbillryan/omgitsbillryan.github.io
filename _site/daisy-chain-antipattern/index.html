<p>There’s an anti-pattern that I often encounter, I call it “The Daisy Chain”. Code that
follows this anti-pattern often looks neat and tidy on the surface.</p>

<h1 id="this-doesnt-seem-so-bad">This Doesn’t Seem so Bad…</h1>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">ThingsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">index</span>
    <span class="n">thing_getter</span> <span class="o">=</span> <span class="no">ThingGetter</span><span class="p">.</span><span class="nf">new</span>
    <span class="n">thing_getter</span><span class="p">.</span><span class="nf">get_all</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>“Seems like a lean controller” you admit to yourself… but then you drill into <code class="language-plaintext highlighter-rouge">things_getter.rb</code>.</p>

<h1 id="a-closer-look">A Closer look</h1>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">ThingGetter</span>
  <span class="k">def</span> <span class="nf">get_all</span>
    <span class="n">validate</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">validate</span>
    <span class="c1"># *validate stuff*
</span>
    <span class="n">log_stuff</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">log_stuff</span>
    <span class="c1"># *log stuff*
</span>
    <span class="n">get_thing_a</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">get_thing_a</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">external_request_a</span>
    <span class="n">get_thing_b</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">get_thing_b</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">external_request_b</span>
    <span class="p">{</span><span class="ss">things: </span><span class="p">{</span><span class="ss">a: </span><span class="n">a</span><span class="p">,</span> <span class="ss">b: </span><span class="n">b</span><span class="p">}}</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p><img class="emoji" title=":scream:" alt=":scream:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f631.png" height="20" width="20"> <img class="emoji" title=":scream:" alt=":scream:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f631.png" height="20" width="20"> <img class="emoji" title=":scream:" alt=":scream:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f631.png" height="20" width="20"></p>

<p>This code has problems.</p>

<ul>
  <li><strong>Abstractions don’t make sense</strong></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">get_all</code> <em>does not</em> in fact return “all things”, it returns “validate” <img class="emoji" title=":man_shrugging:" alt=":man_shrugging:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f937-2642.png" height="20" width="20"></p>

<ul>
  <li><strong>Functions are not reusable</strong></li>
</ul>

<p>It’s not possible to call <code class="language-plaintext highlighter-rouge">log_stuff</code> without also calling <code class="language-plaintext highlighter-rouge">get_thing_a</code>.</p>

<ul>
  <li><strong>There’s Hidden Gotchas</strong></li>
</ul>

<p>When you look at the controller and see <code class="language-plaintext highlighter-rouge">thing_getter.get_all</code>, you quickly assume that it’s getting all the things. In reality it’s doing a lot more than that.</p>

<h1 id="how-to-avoid-this">How To Avoid This</h1>

<p>When code comes out as a stream of conciousness, a developer may simply make a new function when 
the prior function gets too big which results in this function “chaining” effect. Most coding I’ve 
done in practice has been reading &amp; modifying code that wasn’t my own. Do yourfellow developers 
a solid and consider the high-level abstractions at play and encapsulate them properly.</p>
